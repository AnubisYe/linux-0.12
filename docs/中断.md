<!-- TOC depthFrom:1 depthTo:6 withLinks:1 updateOnSave:1 orderedList:0 -->

- [中断](#中断)
	- [要点总结-中断](#要点总结-中断)
	- [实例-除零异常中断](#实例-除零异常中断)
	- [不同类型中断区别(硬件中断+异常+系统调用)](#不同类型中断区别硬件中断异常系统调用)
	- [为什么用FS保存用户段？](#为什么用fs保存用户段)
	- [系统调用过程](#系统调用过程)
	- [硬件中断](#硬件中断)
	- [段间子程序调用](#段间子程序调用)
	- [中断调用和子程序的调用的异同](#中断调用和子程序的调用的异同)
	- [END](#end)

<!-- /TOC -->
# 中断

## 要点总结-中断

* 中断:**CPU不再继续依序执行指令，而是转去处理某一从CPU外部或内部产生的特殊信息**
* Linux中通常分为外部中断（又叫硬件中断）和内部中断（又叫异常）。
* 异常 = 同步中断，硬件中断 = 异步中断
* 硬件中断使得硬件得以发出通知给处理器，本质上是一种电信号，由硬件设备发向处理器，处理器接收到中断后，会马上向操作系统反应此信号的带来，然后就由OS负责处理这些新到来的数据，中断可以随时发生，才不用操心与处理器的时间同步问题。不同的设备对应的中断不同，他们之间的不同从操作系统级来看，差别就在于一个数字标识-----**中断号**。专业一点就叫**中断请求(IRQ)线**,通常IRQ都是一些数值量。有些体系结构上，中断号是固定的，有的是动态分配的，这不是问题所在，问题在于**特定的硬件中断总是与特定的设备相关联，并且内核要知道这些信息，这才是最关键的**,不是么？哈哈.
* 中断随时可以产生，内核随时会被打断。
* 不同设备的中断不同，每个中断都通过一个唯一的数字标识，称为IRQ（中断请求）
* 中断处理的行为和长调用（段间子程序调用）的行为颇为相似，理解长调用的处理过程即可理解中断处理过程。计算机理论中很多概念都是相通的，因此，扎实的基本功完全可以触类旁通的指导我们开发应用程序。
* 中断源-处理器从两种地方接收中断：外部（硬件产生）的中断；软件产生的中断。
* 异常源-处理器接收的异常也有两个来源：处理器检测到的程序错误异常；软件产生的异常。
* 处理器的速度跟外围硬件设备的速度往往不在一个数量级上，甚至几个数量级的差别。所以中断其实发生的慢，但是处理的很快，所以就有一个指标实时性，这个特性有强有弱。
* **中断处理程序是和特定中断相关联的，而不是和设备相关联**，如果一个设备可以产生很多中断，这时该设备的驱动程序也就需要准备多个这样的函数。**一个中断处理程序是设备驱动程序的一部分**，这个我们在linux设备驱动中已经说过，就不说了，后面我也会提到一些。前边说过一个问题：中断是可能随时发生的，因此必须要保证中断处理程序也能随时执行，中断处理程序也要尽可能的快速执行，只有这样才能保证尽可能快地恢复中断代码的执行。
* 中断处理程序上半部(top half)---接收到一个中断，它就立即开始开始执行，但只做严格时限的工作，这些工作都是在所有中断被禁止的情况下完成的。同时，能够被允许稍后完成的工作推迟到下半部(bottom half)去，此后，下半部会被执行，通常情况下，下半部都会在中断处理程序返回时立即执行。

![1531457378583.png](image/1531457378583.png)



![1531454609449.png](image/1531454609449.png)

![1531454633418.png](image/1531454633418.png)
* 以上内容就是大部分硬件故障的中断处理函数的处理过程，剩下的部分就是对8259A中断控制器的中断响应处理和系统调用(俗称**软中断**)
* 分清楚，不管如何都是用的同一个IDT表，但是外设分配的是从32号中断开始，也就是说把0~255个中断向量划分区域用作不同功能。

![1531454720663.png](image/1531454720663.png)

![1531454727394.png](image/1531454727394.png)


![1531454734950.png](image/1531454734950.png)

* 系统调用 = 软中断 = 0x80 = 0b1000 0000 = 128号中断

![1531457699770.png](image/1531457699770.png)

![1531473327853.png](image/1531473327853.png)

![1531473354429.png](image/1531473354429.png)

![1531473362139.png](image/1531473362139.png)

![1531473378909.png](image/1531473378909.png)

![1531473399378.png](image/1531473399378.png)

## 可屏蔽中断和不可屏蔽中断

* 不可屏蔽中断从源头分，既可由 CPU 内部产生，也可由外部 NMI 针脚产生。不可屏蔽中断通常用于故障处理(如:协处理器运算出错,存储器校验出错,I/O通道校验出错等).
*  典型的非屏蔽中断源的例子是电源掉电，一旦出现，必须立即无条件地响应，否则进行其他任何工作都是没有意义的。典型的可屏蔽中断源的例子是打印机中断，CPU对打印机中断请求的响应可以快一些，也可以慢一些，因为让打印机等待儿是完全可以的。
* 对于软中断，它不受IF位的影响，所以属于非屏蔽中断范畴。还有一点，细心的读者会想到：CPU只有两根中断请求输入线，有多个中断源怎么办? 一般借助于外部电路


## 实例-除零异常中断

![1531455106800.png](image/1531455106800.png)

![1531455130649.png](image/1531455130649.png)

![1531455144530.png](image/1531455144530.png)

![1531455157539.png](image/1531455157539.png)


## 不同类型中断区别(硬件中断+异常+系统调用)

* 硬件中断：处理前要发送EOI指令，如果是时钟中断，处理完也要检测信号位图
* 系统调用的中断：最多可带3个参数 ，通过EBX, ECX, EDX传入，处理完也要检测信号位图


## 为什么用FS保存用户段？

**用于执行内核数据空间和用户数据空间之间的数据复制工作。**

优点：

1. 边界检查由CPU自动完成
2. 进入中断时，FS自动保存到内核堆栈，退出中断时自动弹出，不需要特殊处理

## 系统调用过程

1. 保存寄存器原值：DS, FS, ES, EAX

2. 三个参数入栈：EDX, ECX, EBX

3. DS和ES设置成内核数据段0x10，FS设置为用户数据段0x17

4. 测试EAX是否有效

5. 调用相应的C函数

6. 系统调用的返回值入栈

7. 查看执行本次调用的进程的状态，若非就绪或时间片用完，则schedule()（不管有没有schedule()都会进入第八步）

8. 返回到ret_from_sys_all继续执行

9. 若当前进程是进程0或是内核进程，则出栈，退出中断

10. 检查信号位图，调用do_signal()。**ret_from_sys_all中调用do_signal()**

11. 恢复寄存器，退出中断，返回调用程序

## 硬件中断

不带出错码的中断处理过程-asm.s

1. 原寄存器入栈（由硬件完成）：SS, ESP, EFLAGS, CS

2. 中断返回地址入栈：EIP

3. 要调用的函数地址入栈

4. EAX的值与栈顶的值（要调用的函数的地址）交换

5. 其它寄存器入栈：EBX, ECX, EDX, EDI, ESI, EBP, DS, ES, FS

6. 出错号入栈：error_code。如果没有出错号，就0入栈

7. EIP在栈中的地址入栈

8. 所有段寄存器转为内核代码段的段选择符：0x08

9. 调用相关C处理函数

10. 两次出栈（步骤6、步骤7入栈的内容）

11. 弹出除（步骤1、步骤2以外的所有内容）

12. 恢复上下文（硬件完成）

## 段间子程序调用

* 段间调用指返回处 段地址 和 段内偏移量 都将入栈保护
* 段内的调用 与 返回指令 只入栈和退栈段内地址的偏移量



## 中断调用和子程序的调用的异同

1. 两过程定义与作用

子程序是微机基本程序结构中的1种，基本程序结构包括顺序（简单）、分支（判断）、循环、子程序和查表等5种。

子程序是一组可以公用的指令序列，只要给出子程序的入口地址就能从主程序转入子程序。子程序在功能上具有相对的独立性，在执行主程序的过程中往往被多次调用，甚至被不同的程序所调用。一般微机首先执行主程序，碰到调用指令就转去执行子程序，子

程序执行完后，返回指令就返回主程序断点（即调用指令的下一条指令），继续执行没有处理完的主程序，这一过程叫做（主程序）调用子程序过程。

子程序结构可简化程序，防止重复书写错误，并可节省内存空间。计算机中经常把常用的各种通用的程序段编成子程序，提供给用户使用。用户在自己编写的程序中，只要会调用这些子程序，就可大大简化用户编程的困难。


中断是计算机中央处理单元CPU与外设I/O交换数据的一种方式，除此方式外，还有无条件、条件（查询）、存贮器直接存取DMA和I/O通道等四种方式。由于无条件不可靠，条件效率低，DMA和I/O通道两方式硬件复杂，而中断方式CPU效率高，因此一般大多采用中断方式。中断概念是当计算机正在执行某一（主）程序时，收到一中断请求，如果中断响应条件成立，计算机就把正在执行的程序暂停一下，去响应处理这一请求，执行中断服务程序，处理完服务程序后，中断返回指令使计算机返回原来还没有执行完的程序断点处继续执行，这一过程称为中断过程。有了中断，计算机才能具有并行处理，实时处理和故障处理等重要功能。

2. 两过程的联系与区别

2.1 联系

中断与调用子程序两过程属于完全不同的概念，但它们也有不少相似之处。两者都需要保护断点（即下一条指令地址）、跳至子程序或中断服务程序、保护现场、子程序或中断处理、恢复现场、恢复断点（即返回主程序）。两者都可实现嵌套，即正在执行的子程序再调另一子程序或正在处理的中断程序又被另一新中断请求所中断，嵌套可为多级。

正是由于这些表面上的相似处，很容易使学生把两者混淆起来，特别是把中断也看为子程序，这就大错特错了。

2.2 区别

中断过程与调用子程序过程相似点是表面的，从本质上讲两者是完全不一样的。

两者的根本区别主要表现在服务时间与服务对象不一样上。

首先，调用子程序过程发生的时间是已知和固定的，即在主程序中的调用指令（CALL）执行时发生主程序调用子程序，调用指令所在位置是已知和固定的。而中断过程发生的时间一般的随机的，CPU在执行某一主程序时收到中断源提出的中断申请时，就发生中断过程，而中断申请一般由硬件电路产生，申请提出时间是随机的（软中断发生时间是固定的），也可以说，调用子程序是程序设计者事先安排的，而执行中断服务程序是由系统工作环境随机决定的；

其次，子程序完全为主程序服务的，两者属于主从关系，主程序需要子程序时就去调用子程序，并把调用结果带回主程序继续执行。而中断服务程序与主程序两者一般是无关的，不存在谁为谁服务的问题，两者是平行关系；

第三，主程序调用子程序过程完全属于软件处理过程，不需要专门的硬件电路，而中断处理系统是一个软、硬件结合系统，需要专门的硬件电路才能完全中断处理的过程；第四，子程序嵌套可实现若干级，嵌套的最多级数由计算机内存开辟的堆栈大小限制，而中断嵌套级数主要由中断优先级数来决定，一般优先级数不会很大。

## END
